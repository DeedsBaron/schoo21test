# :heavy_check_mark: Тестовое задание школы21
**Задача №2**

Сделать программу, которая бы для строки вида

**str** = "{Пожалуйста|Просто} сделайте так, чтобы это {удивительное|крутое|простое} 
тестовое предложение {изменялось {быстро|мгновенно} случайным образом|менялось 
каждый раз}."; 

Например, для **str**="{A|B|C} тест";
три варианта:
1. "А тест"
2. "Б тест"
3. "С тест"
 
для **str** = "{A|B} {A|B}"; четыре варианта
1. "A A"
2. "B B"
3. "A B"
4. "B A"

для **str** = “{A|D {B|C}} тест”; три варианта
1. “A тест”
2. “D B тест”
3. “D C тест”

выдавала все возможные варианты (вложенность скобок не ограничена) за один запуск.

**Алгоритм**

Очевидно, что для перебора всех возможных вариантов отлично подходит рекурсия.

1. Написать регулярное выражение для паттерна **"{bla bla bla}"**, причем важно учесть вложенность скобок, т.е.<br />
например: **"{изменялось {быстро|мгновенно} случайным образом|менялось каждый раз}"** необходимо, чтобы метчилась самая внутренняя пара скобок - **{быстро|мгновенно}**. **'\\{([^{]+?)\\}'** - данное регулярное выражение прекрасно справляется с задачей.
2. Используя регулярное выражение найти подстроку в исходной строке.
3. Разделить полученную строку на массив строк, в качестве разделителя выступает '|'
4. Пройтись по полученному массиву, заменяя раннее найденную подстроку в п.2 на строку из массива, и вызвать рекурсию для полученной новой строки.
5. Условие выхода из рекурсии - если в строке (которая является аргументов функции) не будет обнаружен символ '|'. Если символ не обнаружен записать значение в map, поскольку при такой рекурсии неизбежны повторяющиеся значения (см. рисунок)![Копия Пустой диаграммой - Страница 1](https://user-images.githubusercontent.com/80648065/158645457-c2d2ef6f-c89a-4203-8a59-71da918aa077.png)

**Псевдо код**
 ```
func (str) {
    if (строка содержит '|') {
        add to map
        return
    }
    substr = подстрока на основе регулярного выражения
    mas = split(substr, '|')
    for mas {
        newstr = заменить в исходной строке substr на mas[i]
        func(newstr)
    }
}
```

**Задача №1**

Дана таблица **Staff (id int, salary int)**.  Id – primary key
Напишите запрос, который возвращает вторую по величине зарплату 
(после самой высокой). Если таковой нет, то запрос должен 
возвращать null.

**Алгоритм**

1.Создать вложенный запрос, который будет выводить вторую по величине зарплату.<br />
2.Создать основной запрос, который проверяет первый на null.
```
SELECT IFNULL( (SELECT DISTINCT salary
                FROM Staff
                ORDER BY salary DESC
                LIMIT 1,1), null) as SecSalary
FROM Staff
```
